//
// Created by alex on 01.03.25.
//

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h> // он нужен для поддерижки констант типа AF_INET
#include <sys/socket.h> // тут уже определена функция socket
#include <netinet/in.h> // это для структуры soakaddr_in
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h> // это для функции read

/*
 * Список вопросов:
 * 1) Зачем мы делаем дублирующие функции Socket и тд и тп - неужели только для поимки багов и вывода ошибок?
 *
*/

int Socket(int domain, int type, int protocol) {
    int res = socket(domain, type, protocol);
    if (res == -1) {
        perror("socket failed"); // вывод в стандартный поток ошибок, по сути ничем не отличатеся от обычного вывода
        exit(EXIT_FAILURE); // Функция exit(), находящаяся в стандартной библиотеке, вызывает немедленное окончание работы программы.
    }
    return res;
}

void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) { // это мы делаем как бы репер для этой функции, чтобы отлавливать ошибки с ней связанные, насколько я понял
    int res = bind(sockfd, addr, addrlen);
    if (res == -1) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
}

void Listen(int sockfd, int backlog) { // это мы как бы опять пишем обертку
    int res = listen(sockfd, backlog);
    if (res == -1) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }
}

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) { // опять мы пишем обертку, чтобы каждый раз не писать проверку на ошбику
    int res = accept(sockfd, addr, addrlen);
    if (res == -1) {
        perror("accept failed");
        exit(EXIT_FAILURE);
    }
    return res;
}


int main() {
    int server = Socket(AF_INET, SOCK_STREAM, 0); // Первая константа, чтобы работать с ipv4, второй параметр говорит, что мы будем польлзоваться TCP протоколом, а если мы хотим пользоваться UDP, то надо было писать SOCK_DGRAM. 0 чтобы поставить значение по умолчанию (ниже лежащего уровня)

    // теперь привязываем сокет к адресу для этого нужна функция bind
    struct sockaddr_in adr = {0}; // использутеся, для того чтобы задать адрес для протокола ipv4
    adr.sin_family = AF_INET;
    adr.sin_port = htons(34543); // может иметь разный порядок байт? от хоста к сети, то есть, то что будет передаваться в сеть будет в нужном для нее порядке
    // еще мы хотим задать ip адрес на котором мы будем слушать, но если указать значение 0.0.0.0, то он будет нулем, а так как у нас в adr = {0} то там все нули (не уверен в этом)
    Bind(server, (struct sockaddr *) &adr, sizeof adr); // перед &adr мы делаем приведение типов
    Listen(server, 5); // слушаем на сокете сервер, и вплоть до 5 клиентов может ожидать в очереди
    socklen_t addrlen = sizeof adr;
    int fd = Accept(server, (struct sockaddr *) &adr, &addrlen); // Принимаем клиента на том сокете, который мы открыли ранее. Информацию о клиенте мы запишем в adr несмотря на то, что мы объявляли его ранее
    // accept вернет другой файловый дискриптор через который можно будет общаться с нашим клиентом
    // вот мы приняли клиента, что же делать дальше. Нужно прочитать сообщение, которое нам клиент посалал
    char buf[256]; // это наш буфер, состоящий из 256 ячеек типа char
    ssize_t nread;// Тип данных ssize_t в языке C представляет собой целочисленный тип, который используется для обозначения размера и количества элементов в операциях ввода-вывода и обработки данных. Он определен в заголовочном файле <sys/types.h> и является знакомым целым числом. Основное его отличие от типа size_t заключается в том, что ssize_t может принимать отрицательные значения.
    nread = read(fd, buf, 256); // для него обертку пока создавать не будем. read вернет количество считанных байт. Считываем от клиента (fd) в buff и указываем максимальное количество знаков, которое можно считать и оно 256, то есть не превышает буфер
    if (nread == -1) { // если функция read возвращает отрицательное значение, то это значит, что она завершилась с провалом
        perror("read failed"); // только если errno задан, то только в этом случае имеет смысл выводить perror
        exit(EXIT_FAILURE);
    }
    if (nread == 0) { // если nread вернула 0, то значит мы достигли конца файла (это прописано в man 2)
        printf("END OF FILE occured\n"); // occured - значит достигли. Это значит что клиент закончил передавать, но это не означает, что он закончил принимать и мы не можем в ответ что-то послать
    }
    // напечатаем на консоль, то что мы получили
    write(STDOUT_FILENO, buf, nread); // nread это то, сколько мы получили байт, то есть если 0, то write ничего не выведет
    // теперь передадим на клиент ответ, типо echo-сервер будет. То есть ответ будет таким же что мы и получили
    write(fd, buf, nread); // то есть на fd (клиента) мы передаем buf размера nread

    // НО МЫ ЭТОГО ДЕЛАТЬ НЕ БУДЕТ - ПОТОМ НАПИШУ ПОЧЕМУ
    //close(fd); // закрываем сокет работы с клиентом
    //close(listen); //закрываем прослушивающий сокет

    return 0;
}